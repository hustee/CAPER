function MILPPreProcessing
global NODE SECTION PARAM

% Find Adjacent Edge Representation of Graph
[NODE.adj] = deal([]);
[NODE.close] = deal(0);
for i = 1:length(SECTION)
    index1 = find(ismember({NODE.ID},SECTION(i).FROM));
    index2 = find(ismember({NODE.ID},SECTION(i).TO));
    
    NODE(index1).adj = [NODE(index1).adj, index2];
    NODE(index2).adj = [NODE(index2).adj, index1];
end

% Run Depth-first Search Algoritm to find Loops
global visited loop
visited = [];
loop = {};
dfs(1,0)

% Find Section IDs for each Loop
S = length(SECTION);
for i = 1:length(loop)
    n = length(loop{i}); % Number of nodes in loop
    
    PARAM.Loop(i).NODE = {NODE(loop{i}).ID}; % Node IDs
    [~,~,ic] = unique([{NODE(loop{i}).ID},{SECTION.FROM},{SECTION.TO}],'stable');
    PARAM.Loop(i).SECTION = {SECTION(ic(n+1:n+S)<=n & ic(n+S+1:n+2*S)<=n).ID};
    
    if length(PARAM.Loop(i).NODE)~=length(PARAM.Loop(i).SECTION)
        warning('Sections in loop %d not correct',i)
        PARAM.Loop(1).SECTION(32) = [];
    end
    
    PARAM.Loop(i).Num = length(PARAM.Loop(i).SECTION);
end

% % Combine cycles with shared edges
% i = 1;
% while i <= length(PARAM.Loop)
%     j = i+1;
%     while j <= length(PARAM.Loop)
%         A = [PARAM.Loop(i).SECTION,PARAM.Loop(j).SECTION];
%         C = unique(A);
%         if length(C)<length(A)
%             PARAM.Loop(i).SECTION = C;
%             PARAM.Loop(i).NODE = unique([PARAM.Loop(i).NODE,PARAM.Loop(j).NODE]);
%             PARAM.Loop(i).Num = PARAM.Loop(i).Num + 1;
%             PARAM.Loop(j) = [];
%         else
%             j = j+1;
%         end
%     end
%     i = i+1;
% end


% Find all Linear Combinations of Cycle Basis
m = 2;
while m<length(PARAM.Loop)
    n = length(PARAM.Loop);
    for i = 1:n-1
        for j = max(i+1,m+1):n
            if ~isempty(intersect(PARAM.Loop(i).SECTION,PARAM.Loop(j).SECTION)) % Loops share a section/sections
                % Find new loop generated by xor of existing loops
                C = setxor(PARAM.Loop(i).SECTION,PARAM.Loop(j).SECTION);
                
                flag = true; %flag = {1-loop has not been previously identified, 0-o.w.}
                for k = 1:length(PARAM.Loop)
                    if length(C)==length(unique([C,PARAM.Loop(k).SECTION]))
                        flag = false;
                    end
                end
                
                if flag
                    PARAM.Loop(end+1).SECTION = C;
                    [~,~,ic] = unique([{SECTION.ID},C],'stable');
                    PARAM.Loop(end).NODE = unique([{SECTION(ic(S+1:end)).FROM},{SECTION(ic(S+1:end)).TO}]);
                    if length(PARAM.Loop(end).NODE)~=length(PARAM.Loop(end).SECTION)
                        warning('Check Last Loop')
                    end
                    
                    PARAM.Loop(end).Num = length(PARAM.Loop(end).SECTION);
                end
                
            end
        end
    end
    m = n;     
end

